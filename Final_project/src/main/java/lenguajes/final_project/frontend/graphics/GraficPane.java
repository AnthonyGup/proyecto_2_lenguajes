/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package lenguajes.final_project.frontend.graphics;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import lenguajes.final_project.backend.graphics.Transition;

/**
 *
 * @author antho
 */
public class GraficPane extends javax.swing.JPanel {

    private ArrayList<Transition> transiciones = new ArrayList();
    
    /**
     * Creates new form graficPane
     */
    public GraficPane() {
        initComponents();
        this.setPreferredSize(new Dimension(800, 300));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (transiciones == null || transiciones.isEmpty()) {
            return;
        }

        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int radioNodo = 30;
        Point centro = new Point(getWidth() / 2, getHeight() / 2);
        int radioDistribucion = 200;

        Map<String, Point> posiciones = new HashMap<>();
        Set<String> estados = new LinkedHashSet<>();

        // Recolectar estados únicos
        for (Transition t : transiciones) {
            estados.add(t.origen);
            estados.add(t.destino);
        }

        // Posicionar q0 al centro
        posiciones.put("q0", centro);

        // Posicionar los demás estados en círculo alrededor de q0
        List<String> restantes = new ArrayList<>(estados);
        restantes.remove("q0");

        int total = restantes.size();
        for (int i = 0; i < total; i++) {
            double angulo = 2 * Math.PI * i / total;
            int x = (int) (centro.x + radioDistribucion * Math.cos(angulo));
            int y = (int) (centro.y + radioDistribucion * Math.sin(angulo));
            posiciones.put(restantes.get(i), new Point(x, y));
        }

        // Dibujar nodos
        for (Map.Entry<String, Point> entry : posiciones.entrySet()) {
            String estado = entry.getKey();
            Point p = entry.getValue();

            g2.setColor(Color.LIGHT_GRAY);
            g2.fillOval(p.x - radioNodo, p.y - radioNodo, radioNodo * 2, radioNodo * 2);
            g2.setColor(Color.BLACK);
            g2.drawOval(p.x - radioNodo, p.y - radioNodo, radioNodo * 2, radioNodo * 2);
            g2.drawString(estado, p.x - 10, p.y + 5);
        }

        // Agrupar transiciones por origen-destino
        Map<String, StringBuilder> agrupadas = new HashMap<>();
        for (Transition t : transiciones) {
            String clave = t.origen + "->" + t.destino;
            agrupadas.putIfAbsent(clave, new StringBuilder());
            agrupadas.get(clave).append(t.simbolo);
        }

        // Dibujar transiciones agrupadas
        g2.setColor(Color.BLUE);
        for (Map.Entry<String, StringBuilder> entry : agrupadas.entrySet()) {
            String[] partes = entry.getKey().split("->");
            String origen = partes[0];
            String destino = partes[1];
            String simbolos = entry.getValue().toString();

            Point p1 = posiciones.get(origen);
            Point p2 = posiciones.get(destino);

            if (origen.equals(destino)) {
                // Dibuja bucle como arco
                g2.drawArc(p1.x - 40, p1.y - 80, 80, 40, 0, 180);
                g2.drawString("'" + simbolos + "'", p1.x - 10, p1.y - 90);
            } else {
                // Dibuja flecha entre estados
                dibujarFlecha(g2, p1, p2);
                int midX = (p1.x + p2.x) / 2;
                int midY = (p1.y + p2.y) / 2;
                g2.drawString("'" + simbolos + "'", midX, midY - 10);
            }
        }
    }

    private void dibujarFlecha(Graphics2D g2, Point origen, Point destino) {
        g2.drawLine(origen.x, origen.y, destino.x, destino.y);

        double dx = destino.x - origen.x;
        double dy = destino.y - origen.y;
        double angulo = Math.atan2(dy, dx);
        int flechaSize = 10;

        int x1 = (int) (destino.x - flechaSize * Math.cos(angulo - Math.PI / 6));
        int y1 = (int) (destino.y - flechaSize * Math.sin(angulo - Math.PI / 6));
        int x2 = (int) (destino.x - flechaSize * Math.cos(angulo + Math.PI / 6));
        int y2 = (int) (destino.y - flechaSize * Math.sin(angulo + Math.PI / 6));

        Polygon flecha = new Polygon();
        flecha.addPoint(destino.x, destino.y);
        flecha.addPoint(x1, y1);
        flecha.addPoint(x2, y2);
        g2.fillPolygon(flecha);
    }

    public void setTransiciones(ArrayList<Transition> transiciones) {
        this.transiciones = transiciones;
        repaint(); // Redibuja el panel cuando se actualizan las transiciones
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
